# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N7dEGW7CDvXDmLcnT3IObAcDySlpYuY0
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

"""Import Library"""

import pandas as pd
import numpy as np
from math import sqrt
from sklearn.neural_network import MLPClassifier
from sklearn import metrics
from sklearn.metrics import mean_squared_error
from sklearn.metrics import classification_report
from sklearn.model_selection import KFold, cross_val_score
from sklearn.preprocessing import MinMaxScaler
from itertools import combinations

data_train = pd.read_excel('drive/My Drive/TA DBD/DATA TRAIN.xlsx', header=1)
#drop data kosong dan drop kolom yang tidak dibutuhkan
data_train = data_train.dropna()
data_train = data_train.drop(columns=['NO','JUMLAH PENGIDAP'])
#set data fitur latih(X_train) dan data target latih (y_train)
y_train = np.array(data_train['Kelas'])
X_train = np.array(data_train.drop(columns=['Kelas']))
print('Shape X_train: ', X_train.shape)
print('Shape y_train: ', y_train.shape)

#import data test
data_test = pd.read_excel('drive/My Drive/TA DBD/DATA TES.xlsx', header=1)
#drop data kosong dan drop kolom yang tidak dibutuhkan
data_test = data_test.dropna()
data_test = data_test.drop(columns=['NO','JUMLAH PENGIDAP'])
#set data fitur uji(X_test) dan data target uji (y_test)
y_test = np.array(data_test['Kelas'])
X_test = np.array(data_test.drop(columns=['Kelas']))
print('Shape X_test: ', X_test.shape)
print('Shape y_test: ', y_test.shape)

#penggabungan data latih dan data uji
X = np.concatenate((X_train,X_test))
y = np.concatenate((y_train,y_test))
print('Shape X: ', X.shape)
print('Shape y: ', y.shape)

def normalization(data):
  scaler = MinMaxScaler()
  data = scaler.fit_transform(data)
  return data

X_norm = normalization(X)

print('X_train_norm shape: ', X_norm.shape)

"""# **Pencarian Hidden Layer Berdasarkan Nilai Error Terkecil**

Normalisasi
"""

kfold = KFold(n_splits=5, random_state=2020, shuffle=True)                                        #menggunakan k-fold dengan nilai k=5, akan dilakukan 5 kali fold

data = {'hidden_layer' : [], 'hidden_layer_size' : [], 'aktivasi' : [], 'Error' : []}             #set array untuk menampung data yag dibutuhkan
hidden_layer = np.arange(5) + 1
fungsi_aktivasi = np.array(['identity'])                                                          #set fungsi aktivasi relu ke array "activation"
for hidden in hidden_layer:
  n_layer = hidden + 2
  neurons = np.arange(2*n_layer)+1
  hidden_layer_sizes = combinations(neurons,hidden)
  hidden_layer_sizes = np.array(list(hidden_layer_sizes))
  hidden_layer_sizes_flip = np.flip(hidden_layer_sizes)
  hidden_layer_sizes = np.concatenate((hidden_layer_sizes,hidden_layer_sizes_flip))
  for hidden_layer_size in hidden_layer_sizes:
    for fungsi in fungsi_aktivasi:
      error = []                                                                                  #siapkan array untuk menampung nilai error
      for train_index, test_index in kfold.split(X, y):
        X_train, X_test = X_norm[train_index], X_norm[test_index]                                           #memasukkan X_train dan X_test ke index array fold train X dan test X
        y_train, y_test = y[train_index], y[test_index]                                            #memasukkan y_train dan y_test ke index array fold train y dan test y
        clf = MLPClassifier(hidden_layer_sizes=tuple(hidden_layer_size), activation=fungsi, random_state=1)  #model klasifikasi ann
        clf.fit(X_train, y_train)                                                                   #proses fitting/train model ann
        predict = clf.predict(X_test)                                                            #menentukan nilai prediksi dari input X pada data test
        rmse = np.sqrt(mean_squared_error(y_test, predict))                                             #hitung RMSE terhadap y_test(output target) dan predict(output prediksi model)
        error.append(rmse)
      error = np.array(error)                                                                        #masukkan nilai error per iterasi ke array
      data['hidden_layer'].append(hidden)
      data['hidden_layer_size'].append(hidden_layer_size)
      data['aktivasi'].append(fungsi)
      data['Error'].append(np.mean(error))

data = pd.DataFrame(data)                                                                             #memasukkan data frame hasil perhitungan di atas ke variabel data
data                                                                                                   #menampilkan variabel data sebagai data frame yang akan di export sbg file excel

"""non normalisasi"""

# kfold = KFold(n_splits=5, random_state=2020, shuffle=True)                                        #menggunakan k-fold dengan nilai k=5, akan dilakukan 5 kali fold

# data = {'hidden_layer' : [], 'hidden_layer_size' : [], 'aktivasi' : [], 'Error' : []}             #set array untuk menampung data yag dibutuhkan
# hidden_layer = np.arange(5) + 1
# fungsi_aktivasi = np.array(['identity'])                                                          #set fungsi aktivasi relu ke array "activation"
# for hidden in hidden_layer:
#   n_layer = hidden + 2
#   neurons = np.arange(2*n_layer)+1
#   hidden_layer_sizes = combinations(neurons,hidden)
#   hidden_layer_sizes = np.array(list(hidden_layer_sizes))
#   hidden_layer_sizes_flip = np.flip(hidden_layer_sizes)
#   hidden_layer_sizes = np.concatenate((hidden_layer_sizes,hidden_layer_sizes_flip))
#   for hidden_layer_size in hidden_layer_sizes:
#     for fungsi in fungsi_aktivasi:
#       error = []                                                                                  #siapkan array untuk menampung nilai error
#       for train_index, test_index in kfold.split(X, y):
#         X_train, X_test = X[train_index], X[test_index]                                           #memasukkan X_train dan X_test ke index array fold train X dan test X
#         y_train, y_test = y[train_index], y[test_index]                                            #memasukkan y_train dan y_test ke index array fold train y dan test y
#         clf = MLPClassifier(hidden_layer_sizes=tuple(hidden_layer_size), activation=fungsi, random_state=1)  #model klasifikasi ann
#         clf.fit(X_train, y_train)                                                                   #proses fitting/train model ann
#         predict = clf.predict(X_test)                                                            #menentukan nilai prediksi dari input X pada data test
#         rmse = np.sqrt(mean_squared_error(y_test, predict))                                             #hitung RMSE terhadap y_test(output target) dan predict(output prediksi model)
#         error.append(rmse)
#       error = np.array(error)                                                                        #masukkan nilai error per iterasi ke array
#       data['hidden_layer'].append(hidden)
#       data['hidden_layer_size'].append(hidden_layer_size)
#       data['aktivasi'].append(fungsi)
#       data['Error'].append(np.mean(error))

# data = pd.DataFrame(data)                                                                             #memasukkan data frame hasil perhitungan di atas ke variabel data
# data

"""# **Menampilkan Hasil Pencarian Hidden Layer dengan Nilai Error Paling Kecil**

normalisasi
"""

# untuk aktivasi identity normalisai
selected = data[['Error']].idxmin()
print(data.loc[selected['Error']])

data.to_excel('Hasil Tuning Parameter & normalisasi KLASIFIKASI.xlsx')

"""non normalisasi"""

# # untuk aktivasi identity
# selected = data[['Error']].idxmin()
# print(data.loc[selected['Error']])

data.to_excel('Hasil Tuning Parameter KLASIFIKASI.xlsx')

"""# **Pengujian Hidden Layer Terpilih**

Pencarian Hidden Layer dengan K-Fold
"""

from numpy import mean
from numpy import std

kfold = KFold(n_splits=5, random_state=1, shuffle=True)

train_fold, test_fold, error = [],[],[]
i=0

for train_index, test_index in kfold.split(X, y):
  print('fold ', i)
  print('train: ', train_index)
  print('test: ', test_index)
  print('Train Fold Index: ', train_index.shape)
  print('Test Fold Index : ', test_index.shape)
  print('')
  X_train, X_test = X_norm[train_index], X_norm[test_index]
  y_train, y_test = y[train_index], y[test_index]
  clf_ann = MLPClassifier(hidden_layer_sizes=(13,7,5,2,1), activation='identity', random_state=1)
  clf_ann.fit(X_train, y_train)
  y_pred = clf_ann.predict(X_test)
  train_fold.append(train_index)
  test_fold.append(test_index)
  rmse = np.sqrt(mean_squared_error(y_test,y_pred))
  error.append(rmse)
  i += 1

print('Errors: ', error)
print('')
scores = cross_val_score(estimator=clf_ann, X=X_norm, y=y, scoring='accuracy', cv=5)
print('')
print('All CV Accuracy : ', scores)
print('CV Mean Accuracy: %.3f' % (mean(scores)))
print('')

"""UJI DATA fold Mnggunakan Normalisasi"""

from numpy import mean
from numpy import std

error = []

clf_fold = MLPClassifier(hidden_layer_sizes=(13,7,5,2,1), activation='identity', random_state=1)
clf_fold.fit(X_norm[train_fold[4]], y[train_fold[4]])

predict_fold = clf_fold.predict(X_norm[test_fold[4]])
rmse = np.sqrt(mean_squared_error(y[test_fold[4]],predict_fold))
error.append(rmse)

scores = cross_val_score(estimator=clf_fold, X=X_norm, y=y, scoring='accuracy', cv=5)

print('')
[coef.shape for coef in clf_fold.coefs_]
print('Bobot: ')
print(clf_fold.coefs_[0])

print('')
print("shape X_train:", X_norm[train_fold[4]].shape)
print("shape X_test :", X_norm[test_fold[4]].shape)
print('Error: ', error)

print('y_fold4  : ', y[test_fold[4]])
print('y_predict: ', predict_fold)

print('All CV Accuracy : ', scores)
print('CV Mean Accuracy: %.9f' % (mean(scores)))
print('')

print('Mislabeled points out of a total %d points: %d' %(X_norm[test_fold[4]].shape[0],(y[test_fold[4]] != predict_fold).sum()))
print('')


#cm = metrics.confusion_matrix(y[test_fold[2]], predict_fold)
##print(cm)
#print(metrics.classification_report(y[test_fold[2]], predict_fold))

.to_excel('Hasil Tuning Parameter & normalisasi KLASIFIKASI.xlsx')

"""5faktor"""